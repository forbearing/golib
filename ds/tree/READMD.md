### **1. 二叉树（Binary Tree）**

-   **每个节点最多有两个子节点**。
-   **用于表达层次关系**，如 XML、HTML 解析等。

### **2. 二叉搜索树（BST - Binary Search Tree）**

-   **满足** `left < root < right`。
-   **用于快速搜索、插入、删除**（时间复杂度 O(log n)）。
-   改进版本：
    -   **AVL 树**：严格平衡的 BST（旋转保持平衡）。
    -   **红黑树（Red-Black Tree）**：较宽松的平衡条件，常用于 **C++ STL map/set、Java TreeMap**。
    -   **Splay 树**：最近访问的节点会提升（自调整）。
    -   **Treap**：结合 **BST 和堆的特性**（随机平衡性）。

### **3. B 树（B-Tree）**

-   **多路搜索树（M-Way Search Tree）**，每个节点有 **多个子节点**。
-   **用于数据库和文件系统索引**。
-   改进版本：
    -   **B+ 树**：所有数据存储在叶子节点（适用于数据库）。
    -   **B\* 树**：比 B+ 树利用率更高。

### **4. Trie（前缀树）**

-   **用于字符串存储和查找（O(m) 复杂度，m 是字符串长度）**。
-   应用：
    -   **自动补全**（Autocomplete）。
    -   **词频统计**。

### **5. 线段树（Segment Tree）**

-   **用于区间查询和更新**（如区间最小值、最大值、和等）。
-   应用：
    -   **动态区间查询（RMQ - Range Minimum Query）**。

### **6. 树状数组（Fenwick Tree / Binary Indexed Tree, BIT）**

-   **比线段树更轻量，适用于前缀和查询**。
-   应用：
    -   **求前缀和、动态修改数组**（如频繁求区间和的场景）。





## **堆和树的对比**

| **数据结构**              | **是否是树** | **是否是二叉树** | **是否平衡**         | **主要用途**  |
| ------------------------- | ------------ | ---------------- | -------------------- | ------------- |
| **普通二叉树**            | ✅ 是         | ✅ 是             | ❌ 可能不平衡         | 基础结构      |
| **二叉搜索树（BST）**     | ✅ 是         | ✅ 是             | ❌ 可能不平衡         | 快速搜索      |
| **AVL 树**                | ✅ 是         | ✅ 是             | ✅ 严格平衡           | 高效搜索      |
| **红黑树**                | ✅ 是         | ✅ 是             | ✅ 近似平衡           | STL map/set   |
| **B 树**                  | ✅ 是         | ❌ 否             | ✅ 平衡               | 数据库索引    |
| **Trie**                  | ✅ 是         | ❌ 否             | ✅                    | 字符串查找    |
| **二叉堆（Binary Heap）** | ✅ 是         | ✅ 是             | ✅ 通过完全二叉树性质 | 优先队列      |
| **斐波那契堆**            | ✅ 是         | ❌ 否             | ✅                    | Dijkstra 算法 |



## **总结**

1.  **树（Tree）是一种通用的数据结构**，包括 **二叉树、BST、B 树、Trie** 等多种变体。

2.  **堆（Heap）是树的一种特殊形式**，通常是 **完全二叉树**，并且满足 **堆序性质**（最小堆/最大堆）。

3.  树的种类

    ：

    -   **二叉树**（普通二叉树、二叉搜索树 BST）。
    -   **平衡二叉树**（AVL 树、红黑树）。
    -   **多叉树**（B 树、B+ 树）。
    -   **特殊树**（Trie、线段树）。

4.  堆的种类

    ：

    -   **二叉堆（Binary Heap）**：用于优先队列。
    -   **二项堆、斐波那契堆**：用于图算法（Dijkstra）。
    -   **配对堆、左偏堆**：适用于动态合并的优先队列。

堆是树的一种特殊形式，它用于优先级管理，而树结构在数据存储和检索方面应用广泛。



## 红黑树

## **🔷 删除调整的 6 种情况（Cases）**

| **Case**   | **情况描述**                                                 | **解决方案**                                                 |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **Case 1** | `node` 是新的根节点（没有 `Parent`）。                       | 直接结束，不需要调整。                                       |
| **Case 2** | `node` 的 `sibling` 是**红色**。                             | 交换 `Parent` 和 `sibling` 颜色，并旋转 `Parent`，将 `sibling` 变成黑色，让 `sibling` 进入 Case 3。 |
| **Case 3** | `node` 的 `sibling` 及其子节点都是**黑色**，且 `Parent` 也是**黑色**。 | 将 `sibling` 变成红色，并**递归处理 `Parent`**，因为 `Parent` 可能也出现了**双黑**问题。 |
| **Case 4** | `node` 的 `sibling` 及其子节点都是**黑色**，但 `Parent` 是**红色**。 | 交换 `Parent` 和 `sibling` 颜色，使红黑树恢复平衡。          |
| **Case 5** | `node` 的 `sibling` 是**黑色**，且 `sibling` 的靠近 `node` 方向的子节点是**红色**，远离 `node` 方向的子节点是**黑色**。 | 交换 `sibling` 和 `sibling` 的左（或右）子节点的颜色，并**旋转 `sibling`**，让 `sibling` 进入 Case 6。 |
| **Case 6** | `node` 的 `sibling` 是**黑色**，且 `sibling` 的远离 `node` 方向的子节点是**红色**。 | 交换 `sibling` 和 `Parent` 颜色，并旋转 `Parent`，然后将 `sibling` 的远子节点变为黑色。调整完成。 |

