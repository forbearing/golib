package splaytree

/*
====================
1. Zig 旋转（单旋转）
- 适用场景：当要访问的节点 X 是根的 直接子节点 时（即 X 是根的左孩子或右孩子）。
- 操作：进行 单次旋转，使 X 成为根节点。

左 Zig 旋转:
- X 变成新的根节点。
- S 变成 X 的右孩子。
- A 作为 X 的左子树
旋转前
    S
   /
  X
 /
A
旋转后
  X
 / \
A   S

右 Zig 旋转
- X 变成新的根节点。
- S 变成 X 的左孩子。
- A 作为 X 的右子树。
旋转前
  S
   \
    X
     \
      A
旋转后
    X
   / \
  S   A



==============================
2. Zig-Zig 旋转（双旋转，同向）
- 适用场景：
  - 当 X 是 S 的 左孩子，且 S 是 G（祖父）的左孩子（即X 和 S 在同一方向）。
  - 或者 X 是 S 的 右孩子，且 S 是 G 的右孩子。

左 Zig-Zig 旋转
- G 对 S 右旋
- S 对 X 右旋
- X 变成新的根节点。
- S 变成 X 的右子树。
- G 变成 S 的右子树。
旋转前
      G
     /
    S
   /
  X
 /
A
旋转后
      X
     / \
    A   S
         \
          G

右 Zig-Zig 旋转
- G 对 S 左旋
- S 对 X 左旋
- X 变成新的根节点。
- S 变成 X 的左子树。
- G 变成 S 的左子树
旋转前
  G
   \
    S
     \
      X
       \
        A
旋转后
      X
     / \
    S   A
   /
  G



==============================
3. Zig-Zag 旋转（双旋转，反向）
适用场景：
- 当 X 是 S 的 左孩子，但 S 是 G 的 右孩子（X 和 S 方向相反）。
- 或者 X 是 S 的 右孩子，但 S 是 G 的 左孩子。

左-右 Zig-Zag 旋转
- S 对 X 右旋
- G 对 X 左旋
- X 变成新的根节点。
- G 变成 X 的左子树。
- S 变成 X 的右子树。
旋转前
      G
       \
        S
       /
      X
     /
    A
对 S 右旋：旋转 S 使 X 上升，并让 S 成为 X 的右子。
      G
       \
        X
       / \
      A   S
对 G 左旋：旋转 G 使 X 上升，并让 G 成为 X 的左子。
      X
     / \
    G   S
   /
  A

右-左 Zig-Zag 旋转
- S 对 X 左旋
- G 对 X 右旋
- X 变成新的根节点。
- S 变成 X 的左子树。
- G 变成 X 的右子树。
旋转前
      G
     /
    S
     \
      X
       \
        A
对 S 左旋：旋转 S 使 X 上升，并让 S 成为 X 的左子。
      G
     /
    X
   / \
  S   A
对 G 右旋：旋转 G 使 X 上升，并让 G 成为 X 的右子。
      X
     / \
    S   G
         \
          A


总结
旋转类型	触发条件	旋转次数
Zig (单旋)	访问节点是根的直接子节点	1
Zig-Zig (双旋，同向)	访问节点与父、祖父在同一方向	2
Zig-Zag (双旋，反向)	访问节点与父、祖父在相反方向	2
这些旋转保证了 Splay Tree 具有自调整性，即最近访问的节点更容易被访问，提高了查找的局部性，从而提升性能。




*/
