package openapigen

import (
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"reflect"
	"strings"
	"sync"

	"github.com/forbearing/golib/config"
	"github.com/forbearing/golib/types"
	"github.com/forbearing/golib/types/consts"
	"github.com/getkin/kin-openapi/openapi3"
)

var (
	doc = &openapi3.T{
		OpenAPI: "3.0.0",
		Paths:   openapi3.NewPaths(),
		Components: &openapi3.Components{
			Schemas:       openapi3.Schemas{},
			RequestBodies: openapi3.RequestBodies{},
			Responses:     openapi3.ResponseBodies{},
		},
	}
	// docMutex protects concurrent access to the global doc variable
	docMutex sync.RWMutex
)

func Write(filename string) error {
	docMutex.RLock()
	data, err := json.MarshalIndent(doc, "", "  ")
	docMutex.RUnlock()
	if err != nil {
		return err
	}
	return os.WriteFile(filename, data, 0o644)
}

func Set[M types.Model, REQ types.Request, RSP types.Response](path string, verb ...consts.HTTPVerb) {
	getOrCreate := func(p string) *openapi3.PathItem {
		if v := doc.Paths.Value(p); v != nil {
			return v
		}
		newPathItem := &openapi3.PathItem{}
		doc.Paths.Set(p, newPathItem)
		return newPathItem
	}

	pathid := path + "/{id}"
	pathbatch := path + "/batch"
	pathipt := path + "/import"
	pathexpt := path + "/export"

	docMutex.Lock()
	pathItem := getOrCreate(path)
	pathidItem := getOrCreate(pathid)
	pathbatchItem := getOrCreate(pathbatch)
	pathiptItem := getOrCreate(pathipt)
	pathexptItem := getOrCreate(pathexpt)
	docMutex.Unlock()

	for _, verb := range buildVerbs(verb...) {
		switch verb {
		case consts.Create:
			setCreate[M, REQ, RSP](path, pathItem)
		case consts.Delete:
			setDelete[M, REQ, RSP](pathid, pathidItem)
		case consts.Update:
			setUpdate[M, REQ, RSP](pathid, pathidItem)
		case consts.Patch:
			setPatch[M, REQ, RSP](pathid, pathidItem)
		case consts.List:
			setList[M, REQ, RSP](path, pathItem)
		case consts.Get:
			setGet[M, REQ, RSP](pathid, pathidItem)
		case consts.Import:
			setImport[M, REQ, RSP](pathipt, pathiptItem)
		case consts.Export:
			setExport[M, REQ, RSP](pathexpt, pathexptItem)
		case consts.CreateMany:
			setCreateMany[M, REQ, RSP](pathbatch, pathbatchItem)
		case consts.DeleteMany:
			setDeleteMany[M, REQ, RSP](pathbatch, pathbatchItem)
		case consts.UpdateMany:
			setUpdateMany[M, REQ, RSP](pathbatch, pathbatchItem)
		case consts.PatchMany:
			setPatchMany[M, REQ, RSP](pathbatch, pathbatchItem)
		}
	}

	docMutex.Lock()
	doc.Paths.Set(path, pathItem)
	doc.Paths.Set(pathid, pathidItem)
	doc.Paths.Set(pathbatch, pathbatchItem)
	doc.Paths.Set(pathipt, pathiptItem)
	doc.Paths.Set(pathexpt, pathexptItem)
	docMutex.Unlock()
}

// func Set[M types.Model](path string, verb ...consts.HTTPVerb) {
// 	// doc := &openapi3.T{
// 	// 	OpenAPI: "3.0.0",
// 	// 	Info: &openapi3.Info{
// 	// 		Title:       "User API",
// 	// 		Description: "API for managing users",
// 	// 		Version:     "1.0.0",
// 	// 	},
// 	// 	Paths: openapi3.NewPaths(),
// 	// }
//
// 	// base scheme
//
// 	// TODO: whether to compare and select
// 	// openapi3.NewStringSchema().WithRequired()
//
// 	schema := openapi3.NewObjectSchema().
// 		WithProperty("id", openapi3.NewStringSchema()).
// 		WithProperty("created_at", openapi3.NewStringSchema()).
// 		WithProperty("updated_at", openapi3.NewStringSchema()).
// 		WithProperty("deleted_at", openapi3.NewStringSchema()).
// 		WithProperty("created_by", openapi3.NewStringSchema()).
// 		WithProperty("updated_by", openapi3.NewStringSchema()).
// 		WithProperty("remark", openapi3.NewStringSchema())
// 	_ = schema
//
// 	// userSchema := openapi3.NewObjectSchema().
// 	// 	WithProperty("id", openapi3.NewIntegerSchema()).
// 	// 	WithProperty("name", openapi3.NewStringSchema())
//
// 	respSchema := new(openapi3.Schema)
// 	typ := reflect.TypeOf(*new(M)).Elem()
// 	buildSchema(typ, respSchema)
//
// 	// inputSchema generated by `M` fields that has "schema" tag
//
// 	verbMap := buildVerbMap(verb...)
// 	if verbMap[consts.Create] {
// 	}
// 	if verbMap[consts.Delete] {
// 	}
// 	if verbMap[consts.Update] {
// 	}
// 	if verbMap[consts.UpdatePartial] {
// 	}
// 	if verbMap[consts.List] {
// 		doc.Paths.Set(path, &openapi3.PathItem{
// 			Get: &openapi3.Operation{
// 				OperationID: "list users",
// 				Summary:     "Get list of users",
// 				Responses: func() *openapi3.Responses {
// 					resp := openapi3.NewResponses()
// 					resp.Set("200", &openapi3.ResponseRef{
// 						Value: &openapi3.Response{
// 							Description: util.ValueOf("List of users"),
// 							Content: openapi3.NewContentWithJSONSchema(
// 								openapi3.NewArraySchema().WithItems(respSchema),
// 							),
// 						},
// 					})
// 					return resp
// 				}(),
// 			},
// 		})
// 	}
// 	if verbMap[consts.Get] {
// 	}
// 	if verbMap[consts.Import] {
// 	}
// 	if verbMap[consts.Export] {
// 	}
// 	if verbMap[consts.BatchCreate] {
// 	}
// 	if verbMap[consts.BatchDelete] {
// 	}
// 	if verbMap[consts.BatchUpdate] {
// 	}
// 	if verbMap[consts.BatchUpdatePartial] {
// 	}
// }

// DocumentHandler returns an http.Handler that serves the OpenAPI document
func DocumentHandler() http.Handler {
	docMutex.Lock()
	setDocInfo(doc)
	docMutex.Unlock()
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		docMutex.RLock()
		// data, _ := json.MarshalIndent(doc, "", "  ")
		data, _ := json.Marshal(doc)
		docMutex.RUnlock()
		w.Write(data)
	})
}

func setDocInfo(doc *openapi3.T) {
	doc.Info = &openapi3.Info{
		Title:       config.App.AppInfo.Name,
		Description: fmt.Sprintf("%s Restful api docs", config.App.AppInfo.Name),
		Version:     config.App.AppInfo.Version,
	}
}

func getFieldTag(field reflect.StructField, tagName string) string {
	val := field.Tag.Get(tagName)
	switch val {
	case "-", "":
		return ""
	default:
		parts := strings.Split(val, ",")
		if len(parts) > 0 {
			return parts[0]
		}
		return ""
	}
}

// the type must be struct or pointer to struct.
func buildSchema(typ reflect.Type, resp *openapi3.Schema) {
	// if len(jsonTag) > 0 {
	// 	fmt.Printf("----- name: %s, type: %v, kind: %v, json: %q, schema: %q\n",
	// 		field.Name, field.Type, field.Type.Kind().String(),
	// 		getFieldTag(field, consts.TAG_JSON), getFieldTag(field, consts.TAG_SCHEMA),
	// 	)
	// }

	for i := range typ.NumField() {
		field := typ.Field(i)
		jsonTag := getFieldTag(field, consts.TAG_JSON)
		switch field.Type.Kind() {
		case reflect.Bool:
			resp = resp.WithProperty(jsonTag, openapi3.NewBoolSchema())
		case reflect.Int8, reflect.Int16, reflect.Int32, reflect.Uint8, reflect.Uint16, reflect.Uint32:
			resp = resp.WithProperty(jsonTag, openapi3.NewInt32Schema())
		case reflect.Int, reflect.Uint, reflect.Int64, reflect.Uint64:
			resp = resp.WithProperty(jsonTag, openapi3.NewInt64Schema())
		case reflect.Float32, reflect.Float64:
			resp = resp.WithProperty(jsonTag, openapi3.NewFloat64Schema())
		case reflect.String:
			resp = resp.WithProperty(jsonTag, openapi3.NewStringSchema())
		case reflect.Pointer:
			typ := field.Type.Elem()
			printTag(field)
			switch typ.Kind() {
			case reflect.Bool:
				resp = resp.WithProperty(jsonTag, openapi3.NewBoolSchema())
			case reflect.Int8, reflect.Int16, reflect.Int32, reflect.Uint8, reflect.Uint16, reflect.Uint32:
				resp = resp.WithProperty(jsonTag, openapi3.NewInt32Schema())
			case reflect.Int, reflect.Uint, reflect.Int64, reflect.Uint64:
				resp = resp.WithProperty(jsonTag, openapi3.NewInt64Schema())
			case reflect.Float32, reflect.Float64:
				resp = resp.WithProperty(jsonTag, openapi3.NewFloat64Schema())
			case reflect.String:
				resp = resp.WithProperty(jsonTag, openapi3.NewStringSchema())
				// case reflect.Struct:
				// 	buildSchema(typ, resp)
			}

		case reflect.Struct:
			buildSchema(field.Type, resp)
		case reflect.Slice:
			// resp = resp.WithProperty(jsonTag, openapi3.NewArraySchema())
		default:
		}
	}
}

func printTag(field reflect.StructField) {
	fmt.Printf("----- [pointer] name: %s, type: %v, kind: %v, json: %q, schema: %q\n",
		field.Name, field.Type, field.Type.Kind().String(), getFieldTag(field, consts.TAG_JSON), getFieldTag(field, consts.TAG_SCHEMA))
}

func buildVerbs(verbs ...consts.HTTPVerb) []consts.HTTPVerb {
	verbMap := make(map[consts.HTTPVerb]bool)

	if len(verbs) == 0 {
		verbMap[consts.Most] = true
	} else {
		for _, verb := range verbs {
			verbMap[verb] = true
		}
	}
	if verbMap[consts.All] {
		verbMap[consts.Most] = true
		verbMap[consts.Import] = true
		verbMap[consts.Export] = true
	}
	if verbMap[consts.Most] {
		verbMap[consts.Create] = true
		verbMap[consts.Delete] = true
		verbMap[consts.Update] = true
		verbMap[consts.Patch] = true
		verbMap[consts.List] = true
		verbMap[consts.Get] = true
		verbMap[consts.CreateMany] = true
		verbMap[consts.DeleteMany] = true
		verbMap[consts.UpdateMany] = true
		verbMap[consts.PatchMany] = true
	}

	vs := make([]consts.HTTPVerb, 0, len(verbMap))
	for verb := range verbMap {
		vs = append(vs, verb)
	}
	return vs
}
