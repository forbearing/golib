package gen

import (
	"go/ast"
	"testing"

	"github.com/forbearing/golib/types/consts"
	"github.com/kr/pretty"
)

func logPrintHelloworld() ast.Stmt {
	return &ast.ExprStmt{
		X: &ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   ast.NewIdent("log"),
				Sel: ast.NewIdent("Println"),
			},
			Args: []ast.Expr{
				&ast.BasicLit{Value: `"hello world"`},
			},
		},
	}
}

func TestBuildModelFile(t *testing.T) {
	tests := []struct {
		name string // description of this test case
		// Named input parameters for target function.
		pkgName      string
		modelImports []string
		stmts        []ast.Stmt
		want         string
		wantErr      bool
	}{
		{
			name:         "user",
			pkgName:      "model",
			modelImports: []string{},
			stmts:        []ast.Stmt{StmtModelRegister("User")},
			want: `// Code generated by golib; DO NOT EDIT.
package model

import "github.com/forbearing/golib/model"

func init() {
	model.Register[*User]()
}
`,
			wantErr: false,
		},
		{
			name:         "user_group",
			pkgName:      "model",
			modelImports: []string{"helloworld/model"},
			stmts: []ast.Stmt{
				StmtModelRegister("User"),
				StmtModelRegister("Group"),
			},
			want: `// Code generated by golib; DO NOT EDIT.
package model

import (
	"helloworld/model"

	"github.com/forbearing/golib/model"
)

func init() {
	model.Register[*User]()
	model.Register[*Group]()
}
`,
			wantErr: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, gotErr := BuildModelFile(tt.pkgName, tt.modelImports, tt.stmts...)
			if gotErr != nil {
				if !tt.wantErr {
					t.Errorf("BuildModelFile() failed: %v", gotErr)
				}
				return
			}
			if tt.wantErr {
				t.Fatal("BuildModelFile() succeeded unexpectedly")
			}
			if got != tt.want {
				t.Errorf("BuildModelFile() = \n%v\n, want \n%v\n", pretty.Sprintf("% #v", got), pretty.Sprintf("% #v", tt.want))
			}
		})
	}
}

func TestBuildServiceFile(t *testing.T) {
	tests := []struct {
		name string // description of this test case
		// Named input parameters for target function.
		pkgName     string
		modelImport []string
		types       []*ast.GenDecl
		stmts       []ast.Stmt
		phase       consts.Phase
		want        string
		wantErr     bool
	}{
		{
			name:        "user",
			pkgName:     "service",
			modelImport: []string{"helloworld/model"},
			types:       []*ast.GenDecl{types("model", "User", "User", "User", consts.PHASE_CREATE, false)},
			stmts:       []ast.Stmt{StmtServiceRegister("user", consts.PHASE_CREATE)},
			want: `// Code generated by golib; DO NOT EDIT.
package service

import (
	"helloworld/model"

	"github.com/forbearing/golib/service"
	"github.com/forbearing/golib/types/consts"
)

func Init() error {
	service.Register[*user](consts.PHASE_CREATE)
	return nil
}

type Creator struct {
	service.Base[*model.User, *model.User, *model.User]
}
`,
			wantErr: false,
		},
		{
			name:        "user_group",
			modelImport: []string{"helloworld/model"},
			pkgName:     "service",
			types: []*ast.GenDecl{
				types("model", "User", "User", "User", consts.PHASE_CREATE, false),
				types("model", "Group", "Group", "Group", consts.PHASE_UPDATE, false),
			},
			stmts: []ast.Stmt{StmtServiceRegister("user", consts.PHASE_CREATE), StmtServiceRegister("group", consts.PHASE_UPDATE)},
			want: `// Code generated by golib; DO NOT EDIT.
package service

import (
	"helloworld/model"

	"github.com/forbearing/golib/service"
	"github.com/forbearing/golib/types/consts"
)

func Init() error {
	service.Register[*user](consts.PHASE_CREATE)
	service.Register[*group](consts.PHASE_UPDATE)
	return nil
}

type Creator struct {
	service.Base[*model.User, *model.User, *model.User]
}

type Updater struct {
	service.Base[*model.Group, *model.Group, *model.Group]
}
`,
			wantErr: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, gotErr := BuildServiceFile(tt.pkgName, tt.modelImport, tt.types, tt.stmts...)
			if gotErr != nil {
				if !tt.wantErr {
					t.Errorf("BuildServiceFile() failed: %v", gotErr)
				}
				return
			}
			if tt.wantErr {
				t.Fatal("BuildServiceFile() succeeded unexpectedly")
			}
			if got != tt.want {
				t.Errorf("BuildServiceFile() = \n%v\n, want \n%v\n", pretty.Sprintf("% #v", got), pretty.Sprintf("% #v", tt.want))
			}
		})
	}
}

func TestBuildRouterFile(t *testing.T) {
	tests := []struct {
		name string // description of this test case
		// Named input parameters for target function.
		pkgName      string
		modelImports []string
		stmts        []ast.Stmt
		want         string
		wantErr      bool
	}{
		{
			name:         "log_println_hello_world",
			pkgName:      "router",
			modelImports: []string{"helloworld/model"},
			stmts:        []ast.Stmt{logPrintHelloworld()},
			want: `// Code generated by golib; DO NOT EDIT.
package router

import (
	"helloworld/model"

	"github.com/forbearing/golib/router"
	"github.com/forbearing/golib/types/consts"
)

func Init() error {
	log.Println("hello world")
	return nil
}
`,
			wantErr: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, gotErr := BuildRouterFile(tt.pkgName, tt.modelImports, tt.stmts...)
			if gotErr != nil {
				if !tt.wantErr {
					t.Errorf("BuildRouterFile() failed: %v", gotErr)
				}
				return
			}
			if tt.wantErr {
				t.Fatal("BuildRouterFile() succeeded unexpectedly")
			}
			if got != tt.want {
				t.Errorf("BuildRouterFile() = \n%v\n, want \n%v\n", pretty.Sprintf("% #v", got), pretty.Sprintf("% #v", tt.want))
			}
		})
	}
}

func TestBuildMainFile(t *testing.T) {
	tests := []struct {
		name string // description of this test case
		// Named input parameters for target function.
		projectName string
		want        string
		wantErr     bool
	}{
		{
			name:        "test1",
			projectName: "helloworld",
			want: `// Code generated by golib; DO NOT EDIT.
package main

import (
	"helloworld/configx"
	"helloworld/cronjobx"
	_ "helloworld/model"
	"helloworld/router"
	"helloworld/service"

	"github.com/forbearing/golib/bootstrap"
	. "github.com/forbearing/golib/util"
)

func main() {
	RunOrDie(bootstrap.Bootstrap)
	RunOrDie(configx.Init)
	RunOrDie(cronjobx.Init)
	RunOrDie(service.Init)
	RunOrDie(router.Init)
	RunOrDie(bootstrap.Run)
}
`,
			wantErr: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, gotErr := BuildMainFile(tt.projectName)
			if gotErr != nil {
				if !tt.wantErr {
					t.Errorf("BuildMainFile() failed: %v", gotErr)
				}
				return
			}
			if tt.wantErr {
				t.Fatal("BuildMainFile() succeeded unexpectedly")
			}
			// TODO: update the condition below to compare got with tt.want.
			if got != tt.want {
				t.Errorf("BuildMainFile() = \n%v,\n want \n%v\n", pretty.Sprintf("% #v", got), pretty.Sprintf("% #v", tt.want))
			}
		})
	}
}
