package gen

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"path"
	"strings"

	"github.com/stoewer/go-strcase"
	goimports "golang.org/x/tools/imports"
	fumpt "mvdan.cc/gofumpt/format"
)

// FormatNode use go standard lib "go/format" to format ast.Node into code.
func FormatNode(node ast.Node, processImport ...bool) (string, error) {
	var buf bytes.Buffer
	fset := token.NewFileSet()

	if err := format.Node(&buf, fset, node); err != nil {
		return "", err
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return "", err
	}

	// Fix comment position: move comments that appear on package line to separate line
	formattedStr := string(formatted)
	formattedStr = fixCommentPosition(formattedStr)

	if len(processImport) > 0 && processImport[0] {
		result, err := goimports.Process("", []byte(formattedStr), nil)
		if err != nil {
			return "", err
		}
		return string(result), nil
	}

	return string(formattedStr), nil
}

// FormatNodeExtra use "https://github.com/mvdan/gofumpt" to format ast.Node into code.
func FormatNodeExtra(node ast.Node, processImport ...bool) (string, error) {
	return FormatNodeExtraWithFileSet(node, nil, processImport...)
}

// FormatNodeExtraWithFileSet 使用指定的 FileSet 格式化节点，保持注释位置
func FormatNodeExtraWithFileSet(node ast.Node, fset *token.FileSet, processImport ...bool) (string, error) {
	var buf bytes.Buffer
	// 如果没有提供 FileSet，创建新的
	if fset == nil {
		fset = token.NewFileSet()
	}

	if err := format.Node(&buf, fset, node); err != nil {
		return "", err
	}

	formatted, err := fumpt.Source(buf.Bytes(), fumpt.Options{
		LangVersion: "",
		ExtraRules:  true,
	})
	if err != nil {
		return "", err
	}

	// Fix comment position: move comments that appear on package line to separate line
	formattedStr := string(formatted)
	formattedStr = fixCommentPosition(formattedStr)

	if len(processImport) > 0 && processImport[0] {
		var result []byte
		if result, err = goimports.Process("", []byte(formattedStr), nil); err != nil {
			return "", err
		}
		return string(result), nil
	}

	return formattedStr, nil
}

// fixCommentPosition fixes the position of generated comments
func fixCommentPosition(code string) string {
	// Fix pattern: "package name // Code generated by..."
	// Replace with: "// Code generated by...\npackage name"
	lines := strings.Split(code, "\n")
	packageLineIndex := -1

	for i, line := range lines {
		if strings.HasPrefix(strings.TrimSpace(line), "package ") {
			packageLineIndex = i
			// Check if there's a comment on the same line
			if commentIdx := strings.Index(line, "// Code generated by"); commentIdx != -1 {
				// Extract package declaration and comment
				packageDecl := strings.TrimSpace(line[:commentIdx])
				comment := strings.TrimSpace(line[commentIdx:])
				// Replace the line with comment first, then package declaration
				lines[i] = comment + "\n" + packageDecl
				packageLineIndex = i + 1 // Update package line index after splitting
			}
			break
		}
	}

	// Add empty line between package and import if not exists
	if packageLineIndex != -1 {
		for i := packageLineIndex; i < len(lines); i++ {
			if strings.HasPrefix(strings.TrimSpace(lines[i]), "import") {
				// Check if there's already an empty line before import
				if i > 0 && strings.TrimSpace(lines[i-1]) != "" {
					// Insert empty line before import
					lines = append(lines[:i], append([]string{""}, lines[i:]...)...)
				}
				break
			}
		}
	}

	return strings.Join(lines, "\n")
}

func MethodAddComments(code string, modelName string) string {
	for _, method := range Methods {
		str := strings.ReplaceAll(strcase.SnakeCase(method), "_", " ")
		// Add comment after log.Info
		searchStr := fmt.Sprintf(`log.Info("%s %s")`, strings.ToLower(modelName), str)
		replaceStr := fmt.Sprintf(`log.Info("%s %s")
	// =============================
	// Add your business logic here.
	// =============================
`, strings.ToLower(modelName), str)

		code = strings.ReplaceAll(code, searchStr, replaceStr)
	}

	return code
}

// ResolveImportConflicts detects import conflicts and generates unique aliases
// Returns a map where key is the import path and value is the alias (empty string means no alias needed)
func ResolveImportConflicts(imports []string) map[string]string {
	aliases := make(map[string]string)
	baseNames := make(map[string][]string) // baseName -> []importPath

	// Group imports by their base package name
	for _, imp := range imports {
		baseName := path.Base(imp)
		baseNames[baseName] = append(baseNames[baseName], imp)
	}

	// Generate aliases for conflicting imports
	for _, paths := range baseNames {
		if len(paths) == 1 {
			// No conflict, no alias needed
			aliases[paths[0]] = ""
		} else {
			// Conflict detected, generate unique aliases
			for _, importPath := range paths {
				alias := generateAlias(importPath)
				aliases[importPath] = alias
			}
		}
	}

	return aliases
}

// generateAlias creates a unique alias for an import path
// For example: "nebula/service/cmdb/machine" -> "cmdb_machine"
func generateAlias(importPath string) string {
	parts := strings.Split(importPath, "/")
	if len(parts) < 2 {
		return path.Base(importPath)
	}

	// Use the last two parts joined with underscore
	// e.g., "nebula/service/cmdb/machine" -> "cmdb_machine"
	return parts[len(parts)-2] + "_" + parts[len(parts)-1]
}
