package gen

import (
	"go/ast"
)

// isServiceMethod1 checks whether a function declaration matches the shape
// generated by GenerateServiceMethod1/ServiceMethod1, which is:
//
//	func (r *recv) Method(ctx *types.ServiceContext, m *<pkg>.<Model>) error
func isServiceMethod1(fn *ast.FuncDecl) bool {
	if fn == nil || fn.Recv == nil || fn.Type == nil || fn.Type.Params == nil || fn.Type.Results == nil {
		return false
	}
	// receiver must be pointer to an ident (e.g., *user)
	if !is_pointer_to_ident(fn.Recv) {
		return false
	}
	// params: (ctx *types.ServiceContext, second *pkg.Model)
	if len(fn.Type.Params.List) != 2 {
		return false
	}
	if !is_ctx_service_context(fn.Type.Params.List[0]) {
		return false
	}
	if !is_star_selector(fn.Type.Params.List[1]) {
		return false
	}
	// results: error
	if len(fn.Type.Results.List) != 1 {
		return false
	}
	if !is_ident_name(fn.Type.Results.List[0].Type, "error") {
		return false
	}
	return true
}

// isServiceMethod2 checks whether a function declaration matches the shape
// generated by GenerateServiceMethod2/ServiceMethod2, which is:
//
//	func (r *recv) Method(ctx *types.ServiceContext, list *[]*<pkg>.<Model>) error
func isServiceMethod2(fn *ast.FuncDecl) bool {
	if fn == nil || fn.Recv == nil || fn.Type == nil || fn.Type.Params == nil || fn.Type.Results == nil {
		return false
	}
	if !is_pointer_to_ident(fn.Recv) {
		return false
	}
	if len(fn.Type.Params.List) != 2 {
		return false
	}
	if !is_ctx_service_context(fn.Type.Params.List[0]) {
		return false
	}
	// Second param must be: *[]*pkg.Model
	if !is_ptr_to_slice_of_star_selector(fn.Type.Params.List[1]) {
		return false
	}
	// results: error
	if len(fn.Type.Results.List) != 1 {
		return false
	}
	if !is_ident_name(fn.Type.Results.List[0].Type, "error") {
		return false
	}
	return true
}

// isServiceMethod3 checks whether a function declaration matches the shape
// generated by GenerateServiceMethod3/ServiceMethod3, which is:
//
//	func (r *recv) Method(ctx *types.ServiceContext, list ...*<pkg>.<Model>) error
func isServiceMethod3(fn *ast.FuncDecl) bool {
	if fn == nil || fn.Recv == nil || fn.Type == nil || fn.Type.Params == nil || fn.Type.Results == nil {
		return false
	}
	if !is_pointer_to_ident(fn.Recv) {
		return false
	}
	if len(fn.Type.Params.List) != 2 {
		return false
	}
	if !is_ctx_service_context(fn.Type.Params.List[0]) {
		return false
	}
	// Second param must be: ...*pkg.Model
	if !is_variadic_star_selector(fn.Type.Params.List[1]) {
		return false
	}
	// results: error
	if len(fn.Type.Results.List) != 1 {
		return false
	}
	if !is_ident_name(fn.Type.Results.List[0].Type, "error") {
		return false
	}
	return true
}

// isServiceMethod4 checks whether a function declaration matches the shape
// generated by GenerateServiceMethod4/ServiceMethod4, which is:
//
//	func (r *recv) Method(ctx *types.ServiceContext, req *<pkg>.<Req>) (*<pkg>.<Rsp>, error)
//	func (r *recv) Method(ctx *types.ServiceContext, req <pkg>.<Req>) (<pkg>.<Rsp>, error)
func isServiceMethod4(fn *ast.FuncDecl) bool {
	if fn == nil || fn.Recv == nil || fn.Type == nil || fn.Type.Params == nil || fn.Type.Results == nil {
		return false
	}
	if !is_pointer_to_ident(fn.Recv) {
		return false
	}
	if len(fn.Type.Params.List) != 2 {
		return false
	}
	if !is_ctx_service_context(fn.Type.Params.List[0]) {
		return false
	}
	// Second param must be: *pkg.Req or pkg.Req
	if !is_star_or_selector(fn.Type.Params.List[1]) {
		return false
	}
	// results: (*pkg.Rsp, error) or (pkg.Rsp, error)
	if len(fn.Type.Results.List) != 2 {
		return false
	}
	if !is_star_or_selector_type(fn.Type.Results.List[0].Type) {
		return false
	}
	if !is_ident_name(fn.Type.Results.List[1].Type, "error") {
		return false
	}
	return true
}

// ---------- helpers ----------

// is_pointer_to_ident checks receiver is like (r *recv).
func is_pointer_to_ident(recv *ast.FieldList) bool { //nolint:staticcheck
	if recv == nil || len(recv.List) != 1 {
		return false
	}
	se, ok := recv.List[0].Type.(*ast.StarExpr)
	if !ok {
		return false
	}
	_, ok = se.X.(*ast.Ident)
	return ok
}

// is_ctx_service_context checks "*types.ServiceContext" type.
func is_ctx_service_context(field *ast.Field) bool { //nolint:staticcheck
	if field == nil {
		return false
	}
	se, ok := field.Type.(*ast.StarExpr)
	if !ok {
		return false
	}
	sel, ok := se.X.(*ast.SelectorExpr)
	if !ok {
		return false
	}
	pkg, ok := sel.X.(*ast.Ident)
	if !ok {
		return false
	}
	return pkg.Name == "types" && sel.Sel != nil && sel.Sel.Name == "ServiceContext"
}

// is_star_selector checks "*pkg.Type".
func is_star_selector(field *ast.Field) bool { //nolint:staticcheck
	if field == nil {
		return false
	}
	return is_star_selector_type(field.Type)
}

// is_star_or_selector checks if the field is either *pkg.Type or pkg.Type
func is_star_or_selector(field *ast.Field) bool { //nolint:staticcheck
	if field == nil {
		return false
	}
	return is_star_or_selector_type(field.Type)
}

func is_star_selector_type(expr ast.Expr) bool { //nolint:staticcheck
	se, ok := expr.(*ast.StarExpr)
	if !ok {
		return false
	}
	sel, ok := se.X.(*ast.SelectorExpr)
	if !ok {
		return false
	}
	_, ok = sel.X.(*ast.Ident)
	if !ok {
		return false
	}
	return sel.Sel != nil
}

// is_selector_type checks if the expression is a SelectorExpr (pkg.Type)
func is_selector_type(expr ast.Expr) bool { //nolint:staticcheck
	sel, ok := expr.(*ast.SelectorExpr)
	if !ok {
		return false
	}
	_, ok = sel.X.(*ast.Ident)
	if !ok {
		return false
	}
	return sel.Sel != nil
}

// is_star_or_selector_type checks if the expression is either *pkg.Type or pkg.Type
func is_star_or_selector_type(expr ast.Expr) bool { //nolint:staticcheck
	return is_star_selector_type(expr) || is_selector_type(expr)
}

// is_ptr_to_slice_of_star_selector checks "*[]*pkg.Type".
func is_ptr_to_slice_of_star_selector(field *ast.Field) bool { //nolint:staticcheck
	if field == nil {
		return false
	}
	se, ok := field.Type.(*ast.StarExpr)
	if !ok {
		return false
	}
	arr, ok := se.X.(*ast.ArrayType)
	if !ok {
		return false
	}
	innerStar, ok := arr.Elt.(*ast.StarExpr)
	if !ok {
		return false
	}
	sel, ok := innerStar.X.(*ast.SelectorExpr)
	if !ok {
		return false
	}
	_, ok = sel.X.(*ast.Ident)
	if !ok {
		return false
	}
	return sel.Sel != nil
}

// is_variadic_star_selector checks "...*pkg.Type".
func is_variadic_star_selector(field *ast.Field) bool { //nolint:staticcheck
	if field == nil {
		return false
	}
	ell, ok := field.Type.(*ast.Ellipsis)
	if !ok {
		return false
	}
	innerStar, ok := ell.Elt.(*ast.StarExpr)
	if !ok {
		return false
	}
	sel, ok := innerStar.X.(*ast.SelectorExpr)
	if !ok {
		return false
	}
	_, ok = sel.X.(*ast.Ident)
	if !ok {
		return false
	}
	return sel.Sel != nil
}

// is_ident_name checks if expr is an identifier with specific name.
func is_ident_name(expr ast.Expr, name string) bool { //nolint:staticcheck
	id, ok := expr.(*ast.Ident)
	return ok && id.Name == name
}

// isServiceType checks if a type declaration is a service struct with embedded service.Base[*Model, *Model, *Model]
// Shape: type user struct { service.Base[*model.User, *model.User, *model.User] }
func isServiceType(spec *ast.TypeSpec) bool {
	if spec == nil || spec.Type == nil {
		return false
	}

	// Must be a struct type
	structType, ok := spec.Type.(*ast.StructType)
	if !ok || structType.Fields == nil {
		return false
	}

	// Check if this struct embeds service.Base[*T, *T, *T]
	for _, field := range structType.Fields.List {
		if len(field.Names) == 0 { // Embedded field
			if is_service_base_with_three_type_params(field.Type) {
				return true
			}
		}
	}
	return false
}

// is_service_base_with_three_type_params checks if the type is service.Base[*T, *T, *T]
func is_service_base_with_three_type_params(expr ast.Expr) bool { //nolint:staticcheck
	// Look for service.Base[T1, T2, T3] pattern
	indexListExpr, ok := expr.(*ast.IndexListExpr)
	if !ok {
		return false
	}

	// Check if X is service.Base
	selectorExpr, ok := indexListExpr.X.(*ast.SelectorExpr)
	if !ok {
		return false
	}

	ident, ok := selectorExpr.X.(*ast.Ident)
	if !ok || ident.Name != "service" {
		return false
	}

	if selectorExpr.Sel.Name != "Base" {
		return false
	}

	// Must have exactly 3 type parameters
	if len(indexListExpr.Indices) != 3 {
		return false
	}

	// All type parameters should be either pointer types (*model.Something) or selector types (model.Something)
	for _, index := range indexListExpr.Indices {
		if _, ok := index.(*ast.StarExpr); ok {
			continue // Pointer type is valid
		}
		if _, ok := index.(*ast.SelectorExpr); ok {
			continue // Non-pointer selector type is also valid
		}
		return false // Neither pointer nor selector type
	}

	return true
}
